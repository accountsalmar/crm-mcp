#!/usr/bin/env python3
"""
Odoo ACL Setup Script - Read-Only Access for ALL Models
========================================================

This script sets up read-only access for a specific Odoo user by:
1. Backing up current user groups and ACLs
2. Creating a "API Read-Only Access" group
3. Creating read-only ACLs for ALL accessible models
4. Updating the user's groups to only include base.group_user + readonly group

Safety Features:
- Full backup before any changes
- Rollback capability (--rollback flag)
- Dry-run mode (--dry-run flag)
- Retry logic with exponential backoff
- Progress bar with ETA
- Checkpoint/resume capability
- Logging to file

Usage:
    # Preview what will happen (no changes)
    python setup_readonly_acl.py --dry-run

    # Run with automatic backup
    python setup_readonly_acl.py

    # Rollback to previous state
    python setup_readonly_acl.py --rollback backups/backup_20250110_123456.json

    # Resume from checkpoint
    python setup_readonly_acl.py --resume

Requirements:
    pip install python-dotenv tqdm colorama

Author: Generated by Claude Code
"""

import os
import sys
import json
import time
import argparse
import logging
import ssl
from datetime import datetime
from pathlib import Path
from typing import Optional, Dict, List, Any, Tuple
import xmlrpc.client

# Optional dependencies with graceful fallback
try:
    from dotenv import load_dotenv
    HAS_DOTENV = True
except ImportError:
    HAS_DOTENV = False
    print("Warning: python-dotenv not installed. Using environment variables only.")

try:
    from tqdm import tqdm
    HAS_TQDM = True
except ImportError:
    HAS_TQDM = False
    print("Warning: tqdm not installed. Progress bars disabled.")

try:
    from colorama import init, Fore, Style
    init()
    HAS_COLORAMA = True
except ImportError:
    HAS_COLORAMA = False
    # Fallback color definitions
    class Fore:
        RED = GREEN = YELLOW = CYAN = MAGENTA = WHITE = RESET = ""
    class Style:
        BRIGHT = RESET_ALL = ""


# ============================================
# Configuration
# ============================================

class Config:
    """Configuration loaded from environment variables or .env file."""

    def __init__(self):
        # Load .env file if available
        if HAS_DOTENV:
            env_path = Path(__file__).parent / '.env'
            if env_path.exists():
                load_dotenv(env_path)

        # Required settings
        self.url = os.getenv('ODOO_URL', '')
        self.db = os.getenv('ODOO_DB', '')
        self.admin_user = os.getenv('ODOO_ADMIN_USER', '')
        self.admin_password = os.getenv('ODOO_ADMIN_PASSWORD', '')
        self.target_user_login = os.getenv('TARGET_USER_LOGIN', '')

        # Optional settings
        self.readonly_group_name = os.getenv('READONLY_GROUP_NAME', 'API Read-Only Access')
        self.backup_dir = Path(os.getenv('BACKUP_DIR', Path(__file__).parent / 'backups'))
        self.log_file = Path(os.getenv('LOG_FILE', Path(__file__).parent / 'logs' / 'acl_setup.log'))
        self.max_retries = int(os.getenv('MAX_RETRIES', '3'))
        self.retry_delay = float(os.getenv('RETRY_DELAY_SECONDS', '2'))
        self.batch_size = int(os.getenv('BATCH_SIZE', '50'))

        # Checkpoint file
        self.checkpoint_file = self.backup_dir / 'checkpoint.json'

    def validate(self) -> List[str]:
        """Validate configuration and return list of errors."""
        errors = []
        if not self.url:
            errors.append("ODOO_URL is required")
        if not self.db:
            errors.append("ODOO_DB is required")
        if not self.admin_user:
            errors.append("ODOO_ADMIN_USER is required")
        if not self.admin_password:
            errors.append("ODOO_ADMIN_PASSWORD is required")
        if not self.target_user_login:
            errors.append("TARGET_USER_LOGIN is required")
        return errors


# ============================================
# Logging Setup
# ============================================

def setup_logging(log_file: Path, verbose: bool = False) -> logging.Logger:
    """Set up logging to both file and console."""
    # Ensure log directory exists
    log_file.parent.mkdir(parents=True, exist_ok=True)

    logger = logging.getLogger('acl_setup')
    logger.setLevel(logging.DEBUG)

    # File handler (always DEBUG level)
    file_handler = logging.FileHandler(log_file, encoding='utf-8')
    file_handler.setLevel(logging.DEBUG)
    file_formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    file_handler.setFormatter(file_formatter)
    logger.addHandler(file_handler)

    # Console handler (INFO or DEBUG based on verbose flag)
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.DEBUG if verbose else logging.INFO)
    console_formatter = logging.Formatter('%(message)s')
    console_handler.setFormatter(console_formatter)
    logger.addHandler(console_handler)

    return logger


# ============================================
# Odoo XML-RPC Client with Retry Logic
# ============================================

class OdooClient:
    """Odoo XML-RPC client with retry logic and error handling."""

    def __init__(self, config: Config, logger: logging.Logger):
        self.config = config
        self.logger = logger
        self.uid: Optional[int] = None
        self.common: Optional[xmlrpc.client.ServerProxy] = None
        self.models: Optional[xmlrpc.client.ServerProxy] = None

    def connect(self) -> bool:
        """Authenticate with Odoo and store UID."""
        try:
            # Create SSL context that doesn't verify certificates
            # (needed for some Odoo instances with self-signed certs)
            ssl_context = ssl.create_default_context()
            ssl_context.check_hostname = False
            ssl_context.verify_mode = ssl.CERT_NONE

            self.common = xmlrpc.client.ServerProxy(
                f'{self.config.url}/xmlrpc/2/common',
                allow_none=True,
                context=ssl_context
            )
            self.models = xmlrpc.client.ServerProxy(
                f'{self.config.url}/xmlrpc/2/object',
                allow_none=True,
                context=ssl_context
            )

            self.uid = self.common.authenticate(
                self.config.db,
                self.config.admin_user,
                self.config.admin_password,
                {}
            )

            if not self.uid:
                self.logger.error(f"{Fore.RED}Authentication failed for admin user{Style.RESET_ALL}")
                return False

            self.logger.info(f"{Fore.GREEN}Connected as admin (UID: {self.uid}){Style.RESET_ALL}")
            return True

        except Exception as e:
            self.logger.error(f"{Fore.RED}Connection error: {e}{Style.RESET_ALL}")
            return False

    def execute_with_retry(self, model: str, method: str, *args, **kwargs) -> Any:
        """Execute Odoo method with retry logic."""
        last_error = None

        for attempt in range(1, self.config.max_retries + 1):
            try:
                result = self.models.execute_kw(
                    self.config.db,
                    self.uid,
                    self.config.admin_password,
                    model,
                    method,
                    list(args),
                    kwargs
                )
                return result

            except xmlrpc.client.Fault as e:
                # Non-retryable error (permission, validation, etc.)
                last_error = e
                self.logger.debug(f"XML-RPC Fault on {model}.{method}: {e.faultString}")
                raise

            except Exception as e:
                # Retryable error (network, timeout, etc.)
                last_error = e
                if attempt < self.config.max_retries:
                    delay = self.config.retry_delay * (2 ** (attempt - 1))  # Exponential backoff
                    self.logger.warning(f"Attempt {attempt}/{self.config.max_retries} failed for {model}.{method}, retrying in {delay}s...")
                    time.sleep(delay)
                else:
                    self.logger.error(f"All {self.config.max_retries} attempts failed for {model}.{method}")
                    raise

        raise last_error


# ============================================
# Backup Manager
# ============================================

class BackupManager:
    """Manages backup and restore of user groups and ACLs."""

    def __init__(self, config: Config, client: OdooClient, logger: logging.Logger):
        self.config = config
        self.client = client
        self.logger = logger
        self.backup_data: Dict[str, Any] = {}

    def create_backup(self, target_user_id: int) -> Path:
        """Create full backup of user groups and existing ACLs."""
        self.logger.info(f"\n{Fore.CYAN}{'='*60}{Style.RESET_ALL}")
        self.logger.info(f"{Fore.CYAN}PHASE 1: Creating Backup{Style.RESET_ALL}")
        self.logger.info(f"{Fore.CYAN}{'='*60}{Style.RESET_ALL}")

        # Ensure backup directory exists
        self.config.backup_dir.mkdir(parents=True, exist_ok=True)

        # Get current user data using search_read (more reliable for fields parameter)
        self.logger.info("Fetching user data...")
        user_data = self.client.execute_with_retry(
            'res.users', 'search_read',
            [('id', '=', target_user_id)],
            fields=['login', 'name', 'groups_id']
        )[0]

        # Get group details
        self.logger.info(f"Fetching {len(user_data['groups_id'])} group details...")
        groups_data = []
        if user_data['groups_id']:
            groups_data = self.client.execute_with_retry(
                'res.groups', 'search_read',
                [('id', 'in', user_data['groups_id'])],
                fields=['name', 'full_name', 'category_id']
            )

        # Get existing ACLs for these groups
        self.logger.info("Fetching existing ACLs for user's groups...")
        acl_data = self.client.execute_with_retry(
            'ir.model.access', 'search_read',
            [('group_id', 'in', user_data['groups_id'])],
            fields=['name', 'model_id', 'group_id', 'perm_read', 'perm_write', 'perm_create', 'perm_unlink']
        )

        # Build backup structure
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        backup_file = self.config.backup_dir / f'backup_{timestamp}.json'

        self.backup_data = {
            'timestamp': timestamp,
            'odoo_url': self.config.url,
            'odoo_db': self.config.db,
            'target_user': {
                'id': target_user_id,
                'login': user_data['login'],
                'name': user_data['name'],
                'original_group_ids': user_data['groups_id']
            },
            'groups': groups_data,
            'acls': acl_data,
            'created_acl_ids': [],  # Will be populated during setup
            'readonly_group_id': None  # Will be populated during setup
        }

        # Save backup
        with open(backup_file, 'w', encoding='utf-8') as f:
            json.dump(self.backup_data, f, indent=2, ensure_ascii=False)

        self.logger.info(f"{Fore.GREEN}Backup saved to: {backup_file}{Style.RESET_ALL}")
        self.logger.info(f"  - User: {user_data['name']} ({user_data['login']})")
        self.logger.info(f"  - Original groups: {len(user_data['groups_id'])}")
        self.logger.info(f"  - Related ACLs: {len(acl_data)}")

        return backup_file

    def rollback(self, backup_file: Path) -> bool:
        """Rollback to a previous backup state."""
        self.logger.info(f"\n{Fore.YELLOW}{'='*60}{Style.RESET_ALL}")
        self.logger.info(f"{Fore.YELLOW}ROLLBACK MODE{Style.RESET_ALL}")
        self.logger.info(f"{Fore.YELLOW}{'='*60}{Style.RESET_ALL}")

        if not backup_file.exists():
            self.logger.error(f"{Fore.RED}Backup file not found: {backup_file}{Style.RESET_ALL}")
            return False

        with open(backup_file, 'r', encoding='utf-8') as f:
            backup = json.load(f)

        self.logger.info(f"Loaded backup from: {backup['timestamp']}")
        self.logger.info(f"Target user: {backup['target_user']['name']}")

        # Restore original groups
        target_user_id = backup['target_user']['id']
        original_group_ids = backup['target_user']['original_group_ids']

        self.logger.info(f"\nRestoring {len(original_group_ids)} original groups...")
        try:
            self.client.execute_with_retry(
                'res.users', 'write',
                [target_user_id],
                {'groups_id': [(6, 0, original_group_ids)]}
            )
            self.logger.info(f"{Fore.GREEN}User groups restored successfully{Style.RESET_ALL}")
        except Exception as e:
            self.logger.error(f"{Fore.RED}Failed to restore groups: {e}{Style.RESET_ALL}")
            return False

        # Optionally delete created ACLs
        created_acl_ids = backup.get('created_acl_ids', [])
        if created_acl_ids:
            self.logger.info(f"\nDeleting {len(created_acl_ids)} created ACLs...")
            try:
                self.client.execute_with_retry(
                    'ir.model.access', 'unlink',
                    [created_acl_ids]
                )
                self.logger.info(f"{Fore.GREEN}Created ACLs deleted successfully{Style.RESET_ALL}")
            except Exception as e:
                self.logger.warning(f"{Fore.YELLOW}Could not delete some ACLs: {e}{Style.RESET_ALL}")

        # Optionally delete readonly group
        readonly_group_id = backup.get('readonly_group_id')
        if readonly_group_id:
            self.logger.info(f"\nDeleting readonly group (ID: {readonly_group_id})...")
            try:
                self.client.execute_with_retry(
                    'res.groups', 'unlink',
                    [[readonly_group_id]]
                )
                self.logger.info(f"{Fore.GREEN}Readonly group deleted successfully{Style.RESET_ALL}")
            except Exception as e:
                self.logger.warning(f"{Fore.YELLOW}Could not delete readonly group: {e}{Style.RESET_ALL}")

        self.logger.info(f"\n{Fore.GREEN}Rollback completed successfully!{Style.RESET_ALL}")
        return True


# ============================================
# Checkpoint Manager (for resume capability)
# ============================================

class CheckpointManager:
    """Manages checkpoints for resume capability."""

    def __init__(self, config: Config, logger: logging.Logger):
        self.config = config
        self.logger = logger
        self.checkpoint: Dict[str, Any] = {}

    def load(self) -> Optional[Dict[str, Any]]:
        """Load existing checkpoint if available."""
        if self.config.checkpoint_file.exists():
            with open(self.config.checkpoint_file, 'r') as f:
                self.checkpoint = json.load(f)
            self.logger.info(f"Loaded checkpoint from: {self.config.checkpoint_file}")
            return self.checkpoint
        return None

    def save(self, data: Dict[str, Any]) -> None:
        """Save checkpoint."""
        self.checkpoint = data
        with open(self.config.checkpoint_file, 'w') as f:
            json.dump(data, f, indent=2)

    def clear(self) -> None:
        """Clear checkpoint after successful completion."""
        if self.config.checkpoint_file.exists():
            self.config.checkpoint_file.unlink()
        self.checkpoint = {}


# ============================================
# ACL Setup Manager
# ============================================

class ACLSetupManager:
    """Main ACL setup logic."""

    # Models to exclude from ACL creation
    EXCLUDE_MODELS = [
        'ir.model',           # Modifying this is dangerous
        'ir.model.access',    # ACL model itself
        'ir.model.fields',    # Field definitions
        'ir.rule',            # Record rules
        'ir.ui.view',         # Views
        'ir.ui.menu',         # Menus
        'ir.actions.',        # Actions (prefix)
        'ir.sequence',        # Sequences
        'ir.cron',            # Scheduled actions
        'ir.config_parameter', # System parameters
        'ir.translation',     # Translations
        'ir.property',        # Properties
        'ir.attachment',      # Attachments (special handling)
        'mail.',              # Mail system (prefix)
        'base.automation',    # Automations
        'res.config.',        # Configuration wizards (prefix)
        'wizard.',            # Wizards (prefix)
    ]

    def __init__(self, config: Config, client: OdooClient,
                 backup_manager: BackupManager, checkpoint_manager: CheckpointManager,
                 logger: logging.Logger):
        self.config = config
        self.client = client
        self.backup_manager = backup_manager
        self.checkpoint_manager = checkpoint_manager
        self.logger = logger
        self.dry_run = False
        self.readonly_group_id: Optional[int] = None
        self.created_acl_ids: List[int] = []
        self.stats = {
            'total_models': 0,
            'processed': 0,
            'created': 0,
            'updated': 0,
            'skipped': 0,
            'failed': 0
        }

    def should_exclude_model(self, model_name: str) -> bool:
        """Check if model should be excluded from ACL creation."""
        for pattern in self.EXCLUDE_MODELS:
            if pattern.endswith('.'):
                # Prefix pattern
                if model_name.startswith(pattern):
                    return True
            else:
                # Exact match
                if model_name == pattern:
                    return True

        # Exclude transient models (wizards)
        if '.transient' in model_name or model_name.startswith('_'):
            return True

        return False

    def get_or_create_readonly_group(self) -> int:
        """Get or create the read-only access group."""
        self.logger.info(f"\n{Fore.CYAN}{'='*60}{Style.RESET_ALL}")
        self.logger.info(f"{Fore.CYAN}PHASE 2: Setting Up Read-Only Group{Style.RESET_ALL}")
        self.logger.info(f"{Fore.CYAN}{'='*60}{Style.RESET_ALL}")

        group_name = self.config.readonly_group_name

        # Check if group already exists
        group_ids = self.client.execute_with_retry(
            'res.groups', 'search',
            [('name', '=', group_name)]
        )

        if group_ids:
            self.readonly_group_id = group_ids[0]
            self.logger.info(f"Found existing group: '{group_name}' (ID: {self.readonly_group_id})")
        else:
            if self.dry_run:
                self.logger.info(f"{Fore.YELLOW}[DRY RUN] Would create group: '{group_name}'{Style.RESET_ALL}")
                self.readonly_group_id = -1  # Placeholder
            else:
                self.readonly_group_id = self.client.execute_with_retry(
                    'res.groups', 'create',
                    [{'name': group_name, 'comment': 'API Read-Only Access - Created by ACL Setup Script'}]
                )
                self.logger.info(f"{Fore.GREEN}Created group: '{group_name}' (ID: {self.readonly_group_id}){Style.RESET_ALL}")

        return self.readonly_group_id

    def get_base_group_user(self) -> int:
        """Get the base.group_user ID (Internal User)."""
        self.logger.info("Looking up base.group_user (Internal User)...")

        group_ids = self.client.execute_with_retry(
            'ir.model.data', 'search_read',
            [('module', '=', 'base'), ('name', '=', 'group_user')],
            fields=['res_id']
        )

        if not group_ids:
            raise ValueError("Could not find base.group_user - this is required for internal users")

        group_user_id = group_ids[0]['res_id']
        self.logger.info(f"Found base.group_user (ID: {group_user_id})")
        return group_user_id

    def get_all_models(self) -> List[Dict[str, Any]]:
        """Get all models from ir.model."""
        self.logger.info("\nFetching all models from ir.model...")

        models = self.client.execute_with_retry(
            'ir.model', 'search_read',
            [('transient', '=', False)],
            fields=['model', 'name'],
            order='model'
        )

        # Filter out excluded models
        filtered_models = [
            m for m in models
            if not self.should_exclude_model(m['model'])
        ]

        self.logger.info(f"Found {len(models)} total models, {len(filtered_models)} after filtering")
        return filtered_models

    def create_acl_for_model(self, model: Dict[str, Any]) -> Tuple[str, Optional[int]]:
        """Create or update read-only ACL for a single model.

        Returns:
            Tuple of (status, acl_id) where status is 'created', 'updated', 'skipped', or 'failed'
        """
        model_name = model['model']
        model_id = model['id']

        # Check if ACL already exists for this group and model
        existing_acl = self.client.execute_with_retry(
            'ir.model.access', 'search_read',
            [
                ('model_id', '=', model_id),
                ('group_id', '=', self.readonly_group_id)
            ],
            fields=['id', 'perm_read', 'perm_write', 'perm_create', 'perm_unlink']
        )

        if existing_acl:
            acl = existing_acl[0]
            # Check if already read-only
            if acl['perm_read'] and not acl['perm_write'] and not acl['perm_create'] and not acl['perm_unlink']:
                return ('skipped', None)

            # Update to read-only
            if self.dry_run:
                return ('would_update', acl['id'])

            try:
                self.client.execute_with_retry(
                    'ir.model.access', 'write',
                    [[acl['id']], {
                        'perm_read': True,
                        'perm_write': False,
                        'perm_create': False,
                        'perm_unlink': False
                    }]
                )
                return ('updated', acl['id'])
            except Exception as e:
                self.logger.debug(f"Failed to update ACL for {model_name}: {e}")
                return ('failed', None)

        # Create new ACL
        acl_name = f"readonly_{model_name.replace('.', '_')}"

        if self.dry_run:
            return ('would_create', None)

        try:
            acl_id = self.client.execute_with_retry(
                'ir.model.access', 'create',
                [{
                    'name': acl_name,
                    'model_id': model_id,
                    'group_id': self.readonly_group_id,
                    'perm_read': True,
                    'perm_write': False,
                    'perm_create': False,
                    'perm_unlink': False
                }]
            )
            self.created_acl_ids.append(acl_id)
            return ('created', acl_id)
        except Exception as e:
            self.logger.debug(f"Failed to create ACL for {model_name}: {e}")
            return ('failed', None)

    def process_models(self, models: List[Dict[str, Any]], start_index: int = 0) -> None:
        """Process all models and create ACLs."""
        self.logger.info(f"\n{Fore.CYAN}{'='*60}{Style.RESET_ALL}")
        self.logger.info(f"{Fore.CYAN}PHASE 3: Creating Read-Only ACLs{Style.RESET_ALL}")
        self.logger.info(f"{Fore.CYAN}{'='*60}{Style.RESET_ALL}")

        self.stats['total_models'] = len(models)

        if start_index > 0:
            self.logger.info(f"Resuming from index {start_index}")

        # Progress bar setup
        if HAS_TQDM:
            pbar = tqdm(
                models[start_index:],
                initial=start_index,
                total=len(models),
                desc="Processing models",
                unit="model"
            )
        else:
            pbar = models[start_index:]

        batch_count = 0

        for model in pbar:
            model_name = model['model']

            try:
                status, acl_id = self.create_acl_for_model(model)

                if status in ('created', 'would_create'):
                    self.stats['created'] += 1
                elif status in ('updated', 'would_update'):
                    self.stats['updated'] += 1
                elif status == 'skipped':
                    self.stats['skipped'] += 1
                elif status == 'failed':
                    self.stats['failed'] += 1

                self.stats['processed'] += 1

            except Exception as e:
                self.stats['failed'] += 1
                self.logger.debug(f"Error processing {model_name}: {e}")

            batch_count += 1

            # Save checkpoint every batch_size models
            if batch_count >= self.config.batch_size:
                self.checkpoint_manager.save({
                    'index': start_index + self.stats['processed'],
                    'created_acl_ids': self.created_acl_ids,
                    'stats': self.stats
                })
                batch_count = 0

        if HAS_TQDM:
            pbar.close()

    def update_user_groups(self, target_user_id: int) -> bool:
        """Update target user's groups to only have read-only access."""
        self.logger.info(f"\n{Fore.CYAN}{'='*60}{Style.RESET_ALL}")
        self.logger.info(f"{Fore.CYAN}PHASE 4: Updating User Groups{Style.RESET_ALL}")
        self.logger.info(f"{Fore.CYAN}{'='*60}{Style.RESET_ALL}")

        # Get base.group_user ID
        base_group_user_id = self.get_base_group_user()

        # New group list: base.group_user + readonly group
        new_group_ids = [base_group_user_id]
        if self.readonly_group_id and self.readonly_group_id > 0:
            new_group_ids.append(self.readonly_group_id)

        self.logger.info(f"Setting user groups to: {new_group_ids}")

        if self.dry_run:
            self.logger.info(f"{Fore.YELLOW}[DRY RUN] Would update user groups{Style.RESET_ALL}")
            return True

        try:
            self.client.execute_with_retry(
                'res.users', 'write',
                [target_user_id],
                {'groups_id': [(6, 0, new_group_ids)]}
            )
            self.logger.info(f"{Fore.GREEN}User groups updated successfully{Style.RESET_ALL}")
            return True
        except Exception as e:
            self.logger.error(f"{Fore.RED}Failed to update user groups: {e}{Style.RESET_ALL}")
            return False

    def verify_permissions(self, target_user_id: int) -> bool:
        """Verify that permissions are correctly set."""
        self.logger.info(f"\n{Fore.CYAN}{'='*60}{Style.RESET_ALL}")
        self.logger.info(f"{Fore.CYAN}PHASE 5: Verification{Style.RESET_ALL}")
        self.logger.info(f"{Fore.CYAN}{'='*60}{Style.RESET_ALL}")

        # Get target user credentials for testing
        # Note: We can't actually test as the user without their password
        # So we verify by checking their group memberships

        user_data = self.client.execute_with_retry(
            'res.users', 'search_read',
            [('id', '=', target_user_id)],
            fields=['login', 'name', 'groups_id']
        )[0]

        self.logger.info(f"User: {user_data['name']} ({user_data['login']})")
        self.logger.info(f"Current groups: {len(user_data['groups_id'])}")

        # Get group details
        if user_data['groups_id']:
            groups = self.client.execute_with_retry(
                'res.groups', 'search_read',
                [('id', 'in', user_data['groups_id'])],
                fields=['name', 'full_name']
            )
            self.logger.info("Group membership:")
            for g in groups:
                self.logger.info(f"  - {g.get('full_name', g['name'])}")

        return True

    def print_summary(self) -> None:
        """Print final summary."""
        self.logger.info(f"\n{Fore.CYAN}{'='*60}{Style.RESET_ALL}")
        self.logger.info(f"{Fore.CYAN}SUMMARY{Style.RESET_ALL}")
        self.logger.info(f"{Fore.CYAN}{'='*60}{Style.RESET_ALL}")

        self.logger.info(f"Total models:     {self.stats['total_models']}")
        self.logger.info(f"Processed:        {self.stats['processed']}")
        self.logger.info(f"{Fore.GREEN}ACLs created:     {self.stats['created']}{Style.RESET_ALL}")
        self.logger.info(f"{Fore.YELLOW}ACLs updated:     {self.stats['updated']}{Style.RESET_ALL}")
        self.logger.info(f"ACLs skipped:     {self.stats['skipped']}")
        self.logger.info(f"{Fore.RED}Failed:           {self.stats['failed']}{Style.RESET_ALL}")


# ============================================
# Main Entry Point
# ============================================

def main():
    parser = argparse.ArgumentParser(
        description='Odoo ACL Setup Script - Read-Only Access for ALL Models',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    # Preview what will happen (no changes)
    python setup_readonly_acl.py --dry-run

    # Run with automatic backup
    python setup_readonly_acl.py

    # Rollback to previous state
    python setup_readonly_acl.py --rollback backups/backup_20250110_123456.json

    # Resume from checkpoint
    python setup_readonly_acl.py --resume

    # Verbose output
    python setup_readonly_acl.py --verbose
        """
    )

    parser.add_argument('--dry-run', action='store_true',
                        help='Preview changes without executing')
    parser.add_argument('--rollback', type=str, metavar='BACKUP_FILE',
                        help='Rollback to a previous backup state')
    parser.add_argument('--resume', action='store_true',
                        help='Resume from last checkpoint')
    parser.add_argument('--verbose', '-v', action='store_true',
                        help='Enable verbose output')
    parser.add_argument('--skip-verify', action='store_true',
                        help='Skip verification phase')

    args = parser.parse_args()

    # Load configuration
    config = Config()

    # Validate configuration
    errors = config.validate()
    if errors:
        print(f"{Fore.RED}Configuration errors:{Style.RESET_ALL}")
        for error in errors:
            print(f"  - {error}")
        print(f"\nPlease create a .env file based on .env.example")
        sys.exit(1)

    # Setup logging
    logger = setup_logging(config.log_file, args.verbose)

    # Print header
    logger.info(f"\n{Fore.MAGENTA}{'='*60}{Style.RESET_ALL}")
    logger.info(f"{Fore.MAGENTA}Odoo ACL Setup Script - Read-Only Access{Style.RESET_ALL}")
    logger.info(f"{Fore.MAGENTA}{'='*60}{Style.RESET_ALL}")
    logger.info(f"URL: {config.url}")
    logger.info(f"Database: {config.db}")
    logger.info(f"Target User: {config.target_user_login}")

    if args.dry_run:
        logger.info(f"{Fore.YELLOW}MODE: DRY RUN (no changes will be made){Style.RESET_ALL}")

    # Initialize client
    client = OdooClient(config, logger)
    if not client.connect():
        sys.exit(1)

    # Initialize managers
    backup_manager = BackupManager(config, client, logger)
    checkpoint_manager = CheckpointManager(config, logger)
    acl_manager = ACLSetupManager(config, client, backup_manager, checkpoint_manager, logger)
    acl_manager.dry_run = args.dry_run

    # Handle rollback mode
    if args.rollback:
        backup_file = Path(args.rollback)
        if backup_manager.rollback(backup_file):
            sys.exit(0)
        else:
            sys.exit(1)

    # Get target user
    logger.info(f"\nLooking up target user: {config.target_user_login}")
    user_ids = client.execute_with_retry(
        'res.users', 'search',
        [('login', '=', config.target_user_login)]
    )

    if not user_ids:
        logger.error(f"{Fore.RED}User not found: {config.target_user_login}{Style.RESET_ALL}")
        sys.exit(1)

    target_user_id = user_ids[0]
    logger.info(f"Found user (ID: {target_user_id})")

    # Confirmation prompt (unless dry-run)
    if not args.dry_run:
        print(f"\n{Fore.YELLOW}WARNING: This will modify permissions for user '{config.target_user_login}'{Style.RESET_ALL}")
        response = input("Type 'YES' to proceed: ")
        if response != 'YES':
            logger.info("Aborted by user")
            sys.exit(0)

    try:
        # Phase 1: Backup
        backup_file = backup_manager.create_backup(target_user_id)

        # Check for resume
        start_index = 0
        if args.resume:
            checkpoint = checkpoint_manager.load()
            if checkpoint:
                start_index = checkpoint.get('index', 0)
                acl_manager.created_acl_ids = checkpoint.get('created_acl_ids', [])
                acl_manager.stats = checkpoint.get('stats', acl_manager.stats)

        # Phase 2: Get/Create readonly group
        acl_manager.get_or_create_readonly_group()

        # Phase 3: Get all models and create ACLs
        models = acl_manager.get_all_models()
        acl_manager.process_models(models, start_index)

        # Phase 4: Update user groups
        acl_manager.update_user_groups(target_user_id)

        # Phase 5: Verification
        if not args.skip_verify:
            acl_manager.verify_permissions(target_user_id)

        # Update backup with created ACL IDs
        backup_manager.backup_data['created_acl_ids'] = acl_manager.created_acl_ids
        backup_manager.backup_data['readonly_group_id'] = acl_manager.readonly_group_id
        with open(backup_file, 'w', encoding='utf-8') as f:
            json.dump(backup_manager.backup_data, f, indent=2, ensure_ascii=False)

        # Clear checkpoint on success
        checkpoint_manager.clear()

        # Print summary
        acl_manager.print_summary()

        if args.dry_run:
            logger.info(f"\n{Fore.YELLOW}DRY RUN COMPLETE - No changes were made{Style.RESET_ALL}")
        else:
            logger.info(f"\n{Fore.GREEN}SETUP COMPLETE!{Style.RESET_ALL}")
            logger.info(f"Backup file: {backup_file}")
            logger.info(f"\nTo rollback: python setup_readonly_acl.py --rollback {backup_file}")

    except KeyboardInterrupt:
        logger.warning(f"\n{Fore.YELLOW}Interrupted by user. Checkpoint saved.{Style.RESET_ALL}")
        sys.exit(1)
    except Exception as e:
        logger.error(f"\n{Fore.RED}Error: {e}{Style.RESET_ALL}")
        logger.info(f"Checkpoint saved. To resume: python setup_readonly_acl.py --resume")
        raise


if __name__ == '__main__':
    main()
